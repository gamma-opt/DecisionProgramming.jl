<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CHD preventative care allocation · DecisionProgramming.jl</title><meta name="title" content="CHD preventative care allocation · DecisionProgramming.jl"/><meta property="og:title" content="CHD preventative care allocation · DecisionProgramming.jl"/><meta property="twitter:title" content="CHD preventative care allocation · DecisionProgramming.jl"/><meta name="description" content="Documentation for DecisionProgramming.jl."/><meta property="og:description" content="Documentation for DecisionProgramming.jl."/><meta property="twitter:description" content="Documentation for DecisionProgramming.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="DecisionProgramming.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DecisionProgramming.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Decision Programming</span><ul><li><a class="tocitem" href="../../decision-programming/influence-diagram/">Influence Diagram</a></li><li><a class="tocitem" href="../../decision-programming/RJT-model/">RJT model</a></li><li><a class="tocitem" href="../../decision-programming/path-based-model/">Path-based model</a></li><li><a class="tocitem" href="../../decision-programming/cvar/">Conditional value-at-risk</a></li><li><a class="tocitem" href="../../decision-programming/analyzing-decision-strategies/">Analyzing Decision Strategies</a></li><li><a class="tocitem" href="../../decision-programming/computational-complexity/">Computational Complexity</a></li></ul></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../used-car-buyer/">Used Car Buyer</a></li><li><a class="tocitem" href="../pig-breeding/">Pig Breeding</a></li><li><a class="tocitem" href="../n-monitoring/">N-Monitoring</a></li><li><a class="tocitem" href="../contingent-portfolio-programming/">Contingent Portfolio Programming</a></li><li class="is-active"><a class="tocitem" href>CHD preventative care allocation</a><ul class="internal"><li><a class="tocitem" href="#Description"><span>Description</span></a></li><li><a class="tocitem" href="#Influence-diagram"><span>Influence diagram</span></a></li><li><a class="tocitem" href="#Generating-the-model"><span>Generating the model</span></a></li><li><a class="tocitem" href="#Solving-the-model"><span>Solving the model</span></a></li><li><a class="tocitem" href="#Analyzing-results"><span>Analyzing results</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>CHD preventative care allocation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CHD preventative care allocation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gamma-opt/DecisionProgramming.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gamma-opt/DecisionProgramming.jl/blob/master/docs/src/examples/CHD_preventative_care.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CHD-preventative-care-allocation"><a class="docs-heading-anchor" href="#CHD-preventative-care-allocation">CHD preventative care allocation</a><a id="CHD-preventative-care-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#CHD-preventative-care-allocation" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>The goal in this optimisation problem is to determine an optimal decision strategy for the testing and treatment decisions involved in providing preventative care for coronary heart disease (CHD). The optimality is evaluated from the perspective of the national health care system and is measured in quality-adjusted life-years (QALY). The tests available in this model are the traditional risk score (TRS) and the genetic risk score (GRS) and the form of preventative care is statin treatment. The description of the CHD preventative care allocation problem is below. This description is from <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> from section 3.2.</p><blockquote><p>The problem setting is such that the patient is assumed to have a prior risk estimate. A risk estimate is a prediction of the patient’s chance of having a CHD event in the next ten years. The risk estimates are grouped into risk levels, which range from 0% to 100%. The first testing decision is made based on the prior risk estimate. The first testing decision entails deciding whether TRS or GRS should be performed or if no testing is needed. If a test is conducted, the risk estimate is updated and based on the new information, the second testing decision is made. The second testing decision entails deciding whether further testing should be conducted or not. The second testing decision is constrained so that the same test which was conducted in the first stage cannot be repeated. If a second test is conducted, the risk estimate is updated again. The treatment decision – dictating whether the patient receives statin therapy or not – is made based on the resulting risk estimate of this testing process. Note that if no tests are conducted, the treatment decision is made based on the prior risk estimate.</p></blockquote><p>In this example, we will showcase the subproblem, which optimises the decision strategy given a single prior risk level. The chosen risk level in this example is 12%. The solution to the main problem is found in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="Influence-diagram"><a class="docs-heading-anchor" href="#Influence-diagram">Influence diagram</a><a id="Influence-diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Influence-diagram" title="Permalink"></a></h2><p><img src="../figures/CHD_preventative_care.svg" alt/></p><p>The influence diagram representation of the problem is seen above. The chance nodes <span>$R$</span> represent the patient&#39;s risk estimate – the prior risk estimate being <span>$R0$</span>. The risk estimate nodes <span>$R0$</span>, <span>$R1$</span> and <span>$R2$</span> have 101 states <span>$R = \{0\%, 1\%, ..., 100\%\}$</span>, which are the discretised risk levels for the risk estimates.</p><p>The risk estimate is updated according to the first and second testing decisions, which are represented by decision nodes <span>$T1$</span> and <span>$T2$</span>. These nodes have states <span>$T = \{\text{TRS, GRS, no test}\}$</span>. The health of the patient, represented by chance node <span>$H$</span>, also affects the update of the risk estimate. In this model, the health of the patient indicates whether they will have a CHD event in the next ten years or not. Thus, the node has states <span>$H = \{\text{CHD, no CHD}\}$</span>. The treatment decision is represented by node <span>$TD$</span> and it has states <span>$TD = \{\text{treatment, no treatment}\}$</span>.</p><p>The prior risk estimate represented by node <span>$R0$</span> influences the health node <span>$H$</span>, because in the model we make the assumption that the prior risk estimate accurately describes the probability of having a CHD event.</p><p>The value nodes in the model are <span>$TC$</span> and <span>$HB$</span>. Node <span>$TC$</span> represents the testing costs incurred due to the testing decisions <span>$T1$</span> and <span>$T2$</span>. Node <span>$HB$</span> represents the health benefits achieved. The testing costs and health benefits are measured in QALYs. These parameter values were evaluated in the study <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>We begin by declaring the chosen prior risk level and reading the conditional probability data for the tests. Note that the sample data in this repository is dummy data due to distribution restrictions on the real data. We also define functions <code>update_risk_distribution</code> and <code>state_probabilities</code>. These functions will be discussed in the following sections.</p><pre><code class="language-julia hljs">using JuMP, HiGHS
using DecisionProgramming
using CSV, DataFrames, PrettyTables


const chosen_risk_level = &quot;12%&quot;
data = CSV.read(&quot;CHD_preventative_care_data.csv&quot;, DataFrame)

function update_risk_distribution(prior::Int64, t::Int64)...
end

function state_probabilities(risk_p::Array{Float64}, t::Int64, h::Int64, prior::Int64)...
end</code></pre><h3 id="Initialise-influence-diagram"><a class="docs-heading-anchor" href="#Initialise-influence-diagram">Initialise influence diagram</a><a id="Initialise-influence-diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Initialise-influence-diagram" title="Permalink"></a></h3><p>We start defining the Decision Programming model by initialising the influence diagram.</p><pre><code class="language-julia hljs">diagram = InfluenceDiagram()</code></pre><p>For brevity in the next sections, we define the states of the nodes to be readily available. Notice, that <span>$R_{states}$</span> is a vector with values <span>$0\%, 1\%,..., 100\%$</span>.</p><pre><code class="language-julia hljs">const H_states = [&quot;CHD&quot;, &quot;no CHD&quot;]
const T_states = [&quot;TRS&quot;, &quot;GRS&quot;, &quot;no test&quot;]
const TD_states = [&quot;treatment&quot;, &quot;no treatment&quot;]
const R_states = [string(x) * &quot;%&quot; for x in [0:1:100;]]</code></pre><p>We then add the nodes. The chance and decision nodes are identified by their names. When declaring the nodes, they are also given information sets and states. Notice that nodes <span>$R0$</span> and <span>$H$</span> are root nodes, meaning that their information sets are empty. In Decision Programming, we add the chance and decision nodes in the follwoing way.</p><pre><code class="language-julia hljs">add_node!(diagram, ChanceNode(&quot;R0&quot;, [], R_states))
add_node!(diagram, ChanceNode(&quot;R1&quot;, [&quot;R0&quot;, &quot;H&quot;, &quot;T1&quot;], R_states))
add_node!(diagram, ChanceNode(&quot;R2&quot;, [&quot;R1&quot;, &quot;H&quot;, &quot;T2&quot;], R_states))
add_node!(diagram, ChanceNode(&quot;H&quot;, [&quot;R0&quot;], H_states))

add_node!(diagram, DecisionNode(&quot;T1&quot;, [&quot;R0&quot;], T_states))
add_node!(diagram, DecisionNode(&quot;T2&quot;, [&quot;R1&quot;], T_states))
add_node!(diagram, DecisionNode(&quot;TD&quot;, [&quot;R2&quot;], TD_states))</code></pre><p>The value nodes are added in a similar fashion. However, value nodes do not have states because they map their information states to utility values instead.</p><pre><code class="language-julia hljs">add_node!(diagram, ValueNode(&quot;TC&quot;, [&quot;T1&quot;, &quot;T2&quot;]))
add_node!(diagram, ValueNode(&quot;HB&quot;, [&quot;H&quot;, &quot;TD&quot;]))</code></pre><h3 id="Generate-arcs"><a class="docs-heading-anchor" href="#Generate-arcs">Generate arcs</a><a id="Generate-arcs-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-arcs" title="Permalink"></a></h3><p>Now that all of the nodes have been added to the influence diagram we generate the arcs between the nodes. This step automatically orders the nodes, gives them indices and reorganises the information into the appropriate form.</p><pre><code class="language-julia hljs">generate_arcs!(diagram)</code></pre><h3 id="Probabilities-of-the-prior-risk-estimate-and-health-of-the-patient"><a class="docs-heading-anchor" href="#Probabilities-of-the-prior-risk-estimate-and-health-of-the-patient">Probabilities of the prior risk estimate and health of the patient</a><a id="Probabilities-of-the-prior-risk-estimate-and-health-of-the-patient-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilities-of-the-prior-risk-estimate-and-health-of-the-patient" title="Permalink"></a></h3><p>In this subproblem, the prior risk estimate is given and therefore the node <span>$R0$</span> is in effect a deterministic node. In Decision Programming a deterministic node is added as a chance node for which the probability of one state is set to one and the probabilities of the rest of the states are set to zero. In this case</p><p class="math-container">\[ℙ(R0 = 12\%)=1\]</p><p>and $ℙ(R0 \neq 12\%)= 0. $</p><p>The probability matrix of node <span>$R0$</span> is added in the following way. Remember that the <code>ProbabilityMatrix</code> function initialises the matrix with zeros.</p><pre><code class="language-julia hljs">X_R0 = ProbabilityMatrix(diagram, &quot;R0&quot;)
X_R0[chosen_risk_level] = 1
add_probabilities!(diagram, &quot;R0&quot;, X_R0)</code></pre><p>Next we add the state probabilities of node <span>$H$</span>. For modeling purposes, we define the information set of node <span>$H$</span> to include the prior risk node <span>$R0$</span>. We set the probability that the patient experiences a CHD event in the next ten years according to the prior risk level such that</p><p class="math-container">\[ℙ(H = \text{CHD} | R0 = \alpha) = \alpha.\]</p><p>We set the probability that the patient does not experience a CHD event in the next ten years as the complement event.</p><p class="math-container">\[ℙ(H = \text{no CHD} | R0 = \alpha) = 1 - \alpha\]</p><p>Since node <span>$R0$</span> is deterministic and the health node <span>$H$</span> is defined in this way, in our model the patient has a 12% chance of experiencing a CHD event and 88% chance of remaining healthy.</p><p>In this Decision Programming model, the probability matrix of node <span>$H$</span> has dimensions (101, 2) because its information set consisting of node <span>$R0$</span> has 101 states and node <span>$H$</span> has 2 states. We first set the column related to the state <span>$CHD$</span> with values from <code>data.risk_levels</code> which are <span>$0.00, 0.01, ..., 0.99, 1.00$</span> and the other column as its complement event.</p><pre><code class="language-julia hljs">X_H = ProbabilityMatrix(diagram, &quot;H&quot;)
X_H[:, &quot;CHD&quot;] = data.risk_levels
X_H[:, &quot;no CHD&quot;] = 1 .- data.risk_levels
add_probabilities!(diagram, &quot;H&quot;, X_H)</code></pre><h3 id="Probabilities-of-the-updated-the-risk-estimates"><a class="docs-heading-anchor" href="#Probabilities-of-the-updated-the-risk-estimates">Probabilities of the updated the risk estimates</a><a id="Probabilities-of-the-updated-the-risk-estimates-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilities-of-the-updated-the-risk-estimates" title="Permalink"></a></h3><p>For node <span>$R1%$</span>, the probabilities of the states are calculated by aggregating the updated risk estimates into the risk levels after a test is performed. The updated risk estimates are calculated using the function <code>update_risk_distribution</code>, which calculates the posterior probability distribution for a given health state, test and prior risk estimate.</p><p class="math-container">\[\textit{risk estimate} = P(\text{CHD} \mid \text{test result}) = \frac{P(\text{test result} \mid \text{CHD})P(\text{CHD})}{P(\text{test result})}\]</p><p>The probabilities <span>$P(\text{test result} \mid \text{CHD})$</span> are test specific and these are read from the CSV data file. The updated risk estimates are aggregated according to the risk levels. These aggregated probabilities are then the state probabilities of node <span>$R1$</span>. The aggregating is done using function <code>state_probabilities</code>.</p><p>In Decision Programming the probability distribution over the states of node <span>$R1$</span> is defined into a probability matrix with dimensions <span>$(101,2,3,101)$</span>. This is because its information set consists of nodes <span>$R0, H$</span> and, <span>$T$</span> which have 101, 2 and 3 states respectively and the node <span>$R1$</span> itself has 101 states. Here, one must know that in Decision Programming the states of the nodes are mapped to numbers in the back-end. For instance, the health states <span>$\text{CHD}$</span> and <span>$\text{no CHD}$</span>  are indexed 1 and 2. The testing decision states TRS, GRS and no test are 1, 2 and 3. The order of the states is determined by the order in which they are defined when adding the nodes. Knowing this, we can set the probability values into the probability matrix using a very compact syntax. Notice that we add 101 probability values at a time into the matrix.</p><pre><code class="language-julia hljs">X_R = ProbabilityMatrix(diagram, &quot;R1&quot;)
for s_R0 = 1:101, s_H = 1:2, s_T1 = 1:3
    X_R[s_R0, s_H,  s_T1, :] =  state_probabilities(update_risk_distribution(s_R0, s_T1), s_T1, s_H, s_R0)
end
add_probabilities!(diagram, &quot;R1&quot;, X_R)</code></pre><p>We notice that the probability distrubtion is identical in <span>$R1$</span> and <span>$R2$</span> because their information states are identical. Therefore we can simply add the same matrix from above as the probability matrix of node <span>$R2$</span>.</p><pre><code class="language-julia hljs">add_probabilities!(diagram, &quot;R2&quot;, X_R)</code></pre><h3 id="Utilities-of-testing-costs-and-health-benefits"><a class="docs-heading-anchor" href="#Utilities-of-testing-costs-and-health-benefits">Utilities of testing costs and health benefits</a><a id="Utilities-of-testing-costs-and-health-benefits-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities-of-testing-costs-and-health-benefits" title="Permalink"></a></h3><p>We define a utility matrix for node <span>$TC$</span>, which maps all its information states to testing costs. The unit in which the testing costs are added is quality-adjusted life-year (QALYs). The utility matrix is defined and added in the following way.</p><pre><code class="language-julia hljs">cost_TRS = -0.0034645
cost_GRS = -0.004
forbidden = 0     #the cost of forbidden test combinations is negligible

Y_TC = UtilityMatrix(diagram, &quot;TC&quot;)
Y_TC[&quot;TRS&quot;, &quot;TRS&quot;] = forbidden
Y_TC[&quot;TRS&quot;, &quot;GRS&quot;] = cost_TRS + cost_GRS
Y_TC[&quot;TRS&quot;, &quot;no test&quot;] = cost_TRS
Y_TC[&quot;GRS&quot;, &quot;TRS&quot;] = cost_TRS + cost_GRS
Y_TC[&quot;GRS&quot;, &quot;GRS&quot;] = forbidden
Y_TC[&quot;GRS&quot;, &quot;no test&quot;] = cost_GRS
Y_TC[&quot;no test&quot;, &quot;TRS&quot;] = cost_TRS
Y_TC[&quot;no test&quot;, &quot;GRS&quot;] = cost_GRS
Y_TC[&quot;no test&quot;, &quot;no test&quot;] = 0
add_utilities!(diagram, &quot;TC&quot;, Y_TC)
</code></pre><p>The health benefits that are achieved are determined by whether treatment is administered and by the health of the patient. We add the final utility matrix to the model.</p><pre><code class="language-julia hljs">Y_HB = UtilityMatrix(diagram, &quot;HB&quot;)
Y_HB[&quot;CHD&quot;, &quot;treatment&quot;] = 6.89713671259061
Y_HB[&quot;CHD&quot;, &quot;no treatment&quot;] = 6.65436854256236
Y_HB[&quot;no CHD&quot;, &quot;treatment&quot;] = 7.64528451705134
Y_HB[&quot;no CHD&quot;, &quot;no treatment&quot;] = 7.70088349200034
add_utilities!(diagram, &quot;HB&quot;, Y_HB)</code></pre><h2 id="Generating-the-model"><a class="docs-heading-anchor" href="#Generating-the-model">Generating the model</a><a id="Generating-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-the-model" title="Permalink"></a></h2><p>In this problem, we want to forbid the model from choosing paths where the same test is repeated twice and where the first testing decision is not to perform a test but the second testing decision is to perform a test. We forbid the paths by declaring these combinations of states as forbidden paths.</p><pre><code class="language-julia hljs">forbidden_tests = ForbiddenPath(diagram, [&quot;T1&quot;,&quot;T2&quot;], [(&quot;TRS&quot;, &quot;TRS&quot;),(&quot;GRS&quot;, &quot;GRS&quot;),(&quot;no test&quot;, &quot;TRS&quot;), (&quot;no test&quot;, &quot;GRS&quot;)])</code></pre><p>We fix the state of the deterministic <span>$R0$</span> node by declaring it as a fixed path. Fixing the state of node <span>$R0$</span> is not necessary because of how the probabilities were defined. However, the fixed state reduces the need for some computation in the back-end.</p><pre><code class="language-julia hljs">fixed_R0 = FixedPath(diagram, Dict(&quot;R0&quot; =&gt; chosen_risk_level))</code></pre><p>Next we generate the decision model. We use path-based formulation (model_type=&quot;DP&quot;) here, because forbidden and fixed paths are not yet a feature of RJT models.</p><pre><code class="language-julia hljs">model, z, x_s = generate_model(diagram, model_type=&quot;DP&quot;, forbidden_paths=[forbidden_tests], fixed=fixed_R0)</code></pre><h2 id="Solving-the-model"><a class="docs-heading-anchor" href="#Solving-the-model">Solving the model</a><a id="Solving-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-model" title="Permalink"></a></h2><p>We set up the solver for the problem and optimise it.</p><pre><code class="language-julia hljs">optimizer = optimizer_with_attributes(
    () -&gt; HiGHS.Optimizer()
)
set_optimizer(model, optimizer)
optimize!(model)</code></pre><h2 id="Analyzing-results"><a class="docs-heading-anchor" href="#Analyzing-results">Analyzing results</a><a id="Analyzing-results-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-results" title="Permalink"></a></h2><p>We extract the results in the following way.</p><pre><code class="language-julia hljs">Z = DecisionStrategy(z)
S_probabilities = StateProbabilities(diagram, Z)
U_distribution = UtilityDistribution(diagram, Z)
</code></pre><h3 id="Decision-strategy"><a class="docs-heading-anchor" href="#Decision-strategy">Decision strategy</a><a id="Decision-strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Decision-strategy" title="Permalink"></a></h3><p>We inspect the decision strategy. From the printout, we can see that when the prior risk level is 12% the optimal decision strategy is to first perform TRS testing. At the second decision stage, GRS should be conducted if the updated risk estimate is between 16% and 28% and otherwise no further testing should be conducted. Treatment should be provided to those who have a final risk estimate greater than 18%. Notice that the incompatible states are not included in the printout. The incompatible states are those that have a state probability of zero, which means that given this data it is impossible for the patient to have their risk estimate updated to those risk levels.</p><pre><code class="language-julia hljs">julia&gt; print_decision_strategy(diagram, Z, S_probabilities)
┌────────────────┬────────────────┐
│ State(s) of R0 │ Decision in T1 │
├────────────────┼────────────────┤
│ 12%            │ TRS            │
└────────────────┴────────────────┘
┌────────────────┬────────────────┐
│ State(s) of R1 │ Decision in T2 │
├────────────────┼────────────────┤
│ 0%             │ no test        │
│ 1%             │ no test        │
│ 3%             │ no test        │
│ 6%             │ no test        │
│ 7%             │ no test        │
│ 10%            │ no test        │
│ 11%            │ no test        │
│ 13%            │ no test        │
│ 14%            │ no test        │
│ 16%            │ GRS            │
│ 17%            │ GRS            │
│ 18%            │ GRS            │
│ 21%            │ GRS            │
│ 22%            │ GRS            │
│ 23%            │ GRS            │
│ 28%            │ no test        │
│ 29%            │ no test        │
│ 31%            │ no test        │
│ 34%            │ no test        │
│  ⋮             │    ⋮            │
└────────────────┴────────────────┘
                                rows omitted

┌────────────────┬────────────────┐
│ State(s) of R2 │ Decision in TD │
├────────────────┼────────────────┤
│ 0%             │ no treatment   │
│ 1%             │ no treatment   │
│ 2%             │ no treatment   │
│ 3%             │ no treatment   │
│ 6%             │ no treatment   │
│ 7%             │ no treatment   │
│ 8%             │ no treatment   │
│ 9%             │ no treatment   │
│ 10%            │ no treatment   │
│ 11%            │ no treatment   │
│ 12%            │ no treatment   │
│ 13%            │ no treatment   │
│ 14%            │ no treatment   │
│ 15%            │ no treatment   │
│ 16%            │ no treatment   │
│ 17%            │ no treatment   │
│ 18%            │ treatment      │
│ 19%            │ treatment      │
│ 20%            │ treatment      │
│  ⋮             │    ⋮            │
└────────────────┴────────────────┘
                                rows omitted</code></pre><h3 id="Utility-distribution"><a class="docs-heading-anchor" href="#Utility-distribution">Utility distribution</a><a id="Utility-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-distribution" title="Permalink"></a></h3><p>We can also print the utility distribution for the optimal strategy and some basic statistics for the distribution.</p><pre><code class="language-julia hljs">julia&gt; print_utility_distribution(U_distribution)
┌──────────┬─────────────┐
│  Utility │ Probability │
│  Float64 │     Float64 │
├──────────┼─────────────┤
│ 6.646904 │    0.005318 │
│ 6.650904 │    0.038707 │
│ 6.889672 │    0.011602 │
│ 6.893672 │    0.064374 │
│ 7.637820 │    0.034188 │
│ 7.641820 │    0.073974 │
│ 7.693419 │    0.035266 │
│ 7.697419 │    0.736573 │
└──────────┴─────────────┘</code></pre><pre><code class="language-julia hljs">julia&gt; print_statistics(U_distribution)
┌──────────┬────────────┐
│     Name │ Statistics │
│   String │    Float64 │
├──────────┼────────────┤
│     Mean │   7.583923 │
│      Std │   0.291350 │
│ Skewness │  -2.414877 │
│ Kurtosis │   4.059711 │
└──────────┴────────────┘</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hankimaa H. (2021). Optimising the use of genetic testing in prevention of CHD using Decision Programming. http://urn.fi/URN:NBN:fi:aalto-202103302644</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Hynninen Y. (2019). Value of genetic testing in the prevention of coronary heart disease events. PLOS ONE, 14(1):1–16. https://doi.org/10.1371/journal.pone.0210010</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contingent-portfolio-programming/">« Contingent Portfolio Programming</a><a class="docs-footer-nextpage" href="../../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.2 on <span class="colophon-date" title="Wednesday 14 May 2025 08:31">Wednesday 14 May 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
