<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>N-Monitoring · DecisionProgramming.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="DecisionProgramming.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DecisionProgramming.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Decision Programming</span><ul><li><a class="tocitem" href="../../decision-programming/influence-diagram/">Influence Diagram</a></li><li><a class="tocitem" href="../../decision-programming/paths/">Paths</a></li><li><a class="tocitem" href="../../decision-programming/decision-model/">Decision Model</a></li><li><a class="tocitem" href="../../decision-programming/analyzing-decision-strategies/">Analyzing Decision Strategies</a></li><li><a class="tocitem" href="../../decision-programming/computational-complexity/">Computational Complexity</a></li></ul></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../used-car-buyer/">Used Car Buyer</a></li><li><a class="tocitem" href="../pig-breeding/">Pig Breeding</a></li><li class="is-active"><a class="tocitem" href>N-Monitoring</a><ul class="internal"><li><a class="tocitem" href="#Description"><span>Description</span></a></li><li><a class="tocitem" href="#Influence-Diagram"><span>Influence Diagram</span></a></li><li><a class="tocitem" href="#Decision-Model"><span>Decision Model</span></a></li><li><a class="tocitem" href="#Analyzing-Results"><span>Analyzing Results</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../contingent-portfolio-programming/">Contingent Portfolio Programming</a></li><li><a class="tocitem" href="../CHD_preventative_care/">CHD preventative care allocation</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>N-Monitoring</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>N-Monitoring</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gamma-opt/DecisionProgramming.jl/blob/master/docs/src/examples/n-monitoring.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="N-Monitoring"><a class="docs-heading-anchor" href="#N-Monitoring">N-Monitoring</a><a id="N-Monitoring-1"></a><a class="docs-heading-anchor-permalink" href="#N-Monitoring" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>The <span>$N$</span>-monitoring problem is described in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, sections 4.1 and 6.1.</p><h2 id="Influence-Diagram"><a class="docs-heading-anchor" href="#Influence-Diagram">Influence Diagram</a><a id="Influence-Diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Influence-Diagram" title="Permalink"></a></h2><p><img src="../figures/n-monitoring.svg" alt/></p><p>The influence diagram of the generalized <span>$N$</span>-monitoring problem where <span>$N≥1$</span> and indices <span>$k=1,...,N.$</span> The nodes are associated with states as follows. <strong>Load state</strong> <span>$L=\{high, low\}$</span> denotes the load on a structure, <strong>report states</strong> <span>$R_k=\{high, low\}$</span> report the load state to the <strong>action states</strong> <span>$A_k=\{yes, no\}$</span> which represent different decisions to fortify the structure. The <strong>failure state</strong> <span>$F=\{failure, success\}$</span> represents whether or not the (fortified) structure fails under the load <span>$L$</span>. Finally, the utility at target <span>$T$</span> depends on the fortification costs and whether F fails.</p><p>We begin by choosing <span>$N$</span> and defining our fortification cost function. We draw the cost of fortification <span>$c_k∼U(0,1)$</span> from a uniform distribution, and the magnitude of fortification is directly proportional to the cost. Fortification is defined as</p><p class="math-container">\[f(A_k=yes) = c_k\]</p><p class="math-container">\[f(A_k=no) = 0\]</p><pre><code class="language-julia hljs">using Logging, Random
using JuMP, Gurobi
using DecisionProgramming

const N = 4

Random.seed!(13)
const c_k = rand(N)
const b = 0.03
fortification(k, a) = [c_k[k], 0][a]</code></pre><h3 id="Initialising-the-influence-diagram"><a class="docs-heading-anchor" href="#Initialising-the-influence-diagram">Initialising the influence diagram</a><a id="Initialising-the-influence-diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-the-influence-diagram" title="Permalink"></a></h3><p>We initialise the influence diagram before adding nodes to it.</p><pre><code class="language-julia hljs">diagram = InfluenceDiagram</code></pre><h3 id="Adding-nodes"><a class="docs-heading-anchor" href="#Adding-nodes">Adding nodes</a><a id="Adding-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-nodes" title="Permalink"></a></h3><p>Add node <span>$L$</span> which represents the load on the structure. This node is the root node and thus, has an empty information set. Its states describe the state of the load, they are <span>$high$</span> and <span>$low$</span>.</p><pre><code class="language-julia hljs">add_node!(diagram, ChanceNode(&quot;L&quot;, [], [&quot;high&quot;, &quot;low&quot;]))</code></pre><p>The report nodes <span>$R_k$</span> and action nodes <span>$A_k$</span> are easily added with a for-loop. The report nodes have node <span>$L$</span> in their information sets and their states are <span>$high$</span> and <span>$low$</span>. The actions are made based on these reports, which is represented by the action nodes <span>$A_k$</span> having the report nodes <span>$R_k$</span> in their information sets. The action nodes have states <span>$yes$</span> and <span>$no$</span>, which represents decisions whether to fortify the structure or not.</p><pre><code class="language-julia hljs">for i in 1:N
    add_node!(diagram, ChanceNode(&quot;R$i&quot;, [&quot;L&quot;], [&quot;high&quot;, &quot;low&quot;]))
    add_node!(diagram, DecisionNode(&quot;A$i&quot;, [&quot;R$i&quot;], [&quot;yes&quot;, &quot;no&quot;]))
end</code></pre><p>The failure node <span>$F$</span> has the load node <span>$L$</span> and all of the action nodes <span>$A_k$</span> in its information set. The failure node has states <span>$failure$</span> and <span>$success$</span>.</p><pre><code class="language-julia hljs">add_node!(diagram, ChanceNode(&quot;F&quot;, [&quot;L&quot;, [&quot;A$i&quot; for i in 1:N]...], [&quot;failure&quot;, &quot;success&quot;]))</code></pre><p>The value node <span>$T$</span> is added as follows.</p><pre><code class="language-julia hljs">add_node!(diagram, ValueNode(&quot;T&quot;, [&quot;F&quot;, [&quot;A$i&quot; for i in 1:N]...]))</code></pre><h3 id="Generating-arcs"><a class="docs-heading-anchor" href="#Generating-arcs">Generating arcs</a><a id="Generating-arcs-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-arcs" title="Permalink"></a></h3><p>Now that all of the nodes have been added to the influence diagram we generate the arcs between the nodes. This step automatically orders the nodes, gives them indices and reorganises the information into the appropriate form.</p><pre><code class="language-julia hljs">generate_arcs!(diagram)</code></pre><h3 id="Load-State-Probabilities"><a class="docs-heading-anchor" href="#Load-State-Probabilities">Load State Probabilities</a><a id="Load-State-Probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Load-State-Probabilities" title="Permalink"></a></h3><p>After generating the arcs, the probabilities and utilities can be added. The probability that the load is high, <span>$ℙ(L=high)$</span>, is drawn from a uniform distribution. For different syntax options for adding probabilities and utilities, see the <a href="../../usage/">usage page</a>.</p><p class="math-container">\[ℙ(L=high)∼U(0,1)\]</p><pre><code class="language-julia hljs">X_L = [rand(), 0]
X_L[2] = 1.0 - X_L[1]
add_probabilities!(diagram, &quot;L&quot;, X_L)</code></pre><h3 id="Reporting-Probabilities"><a class="docs-heading-anchor" href="#Reporting-Probabilities">Reporting Probabilities</a><a id="Reporting-Probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Reporting-Probabilities" title="Permalink"></a></h3><p>The probabilities of the report states correspond to the load state. We draw the values <span>$x∼U(0,1)$</span> and <span>$y∼U(0,1)$</span> from uniform distributions.</p><p class="math-container">\[ℙ(R_k=high∣L=high)=\max\{x,1-x\}\]</p><p class="math-container">\[ℙ(R_k=low∣L=low)=\max\{y,1-y\}\]</p><p>The probability of a correct report is thus in the range [0.5,1]. (This reflects the fact that a probability under 50% would not even make sense, since we would notice that if the test suggests a high load, the load is more likely to be low, resulting in that a low report &quot;turns into&quot; a high report and vice versa.)</p><p>In Decision Programming we add these probabilities by declaring probabilty matrices for nodes <span>$R_k$</span>. The probability matrix of a report node <span>$R_k$</span> has dimensions (2,2), where the rows correspond to the states <span>$high$</span> and <span>$low$</span> of its predecessor node <span>$L$</span> and the columns to its own states <span>$high$</span> and <span>$low$</span>.</p><pre><code class="language-julia hljs">for i in 1:N
    x, y = rand(2)
    X_R = ProbabilityMatrix(diagram, &quot;R$i&quot;)
    X_R[&quot;high&quot;, &quot;high&quot;] = max(x_R, 1-x_R)
    X_R[&quot;high&quot;, &quot;low&quot;] = 1 - max(x_R, 1-x_R)
    X_R[&quot;low&quot;, &quot;low&quot;] = max(y_R, 1-y_R)
    X_R[&quot;low&quot;, &quot;high&quot;] = 1-max(y_R, 1-y_R)
    add_probabilities!(diagram, &quot;R$i&quot;, X_R)
end</code></pre><h3 id="Probability-of-Failure"><a class="docs-heading-anchor" href="#Probability-of-Failure">Probability of Failure</a><a id="Probability-of-Failure-1"></a><a class="docs-heading-anchor-permalink" href="#Probability-of-Failure" title="Permalink"></a></h3><p>The probability of failure is decresead by fortification actions. We draw the values <span>$x∼U(0,1)$</span> and <span>$y∼U(0,1)$</span> from uniform distribution.</p><p class="math-container">\[ℙ(F=failure∣A_N,...,A_1,L=high)=\frac{\max{\{x, 1-x\}}}{\exp{(b ∑_{k=1,...,N} f(A_k))}}\]</p><p class="math-container">\[ℙ(F=failure∣A_N,...,A_1,L=low)=\frac{\min{\{y, 1-y\}}}{\exp{(b ∑_{k=1,...,N} f(A_k))}}\]</p><p>First we initialise the probability matrix for node <span>$F$</span>.</p><pre><code class="language-julia hljs">X_F = ProbabilityMatrix(diagram, &quot;F&quot;)</code></pre><p>This matrix has dimensions <span>$(2, \textcolor{orange}{2, 2, 2, 2}, 2)$</span> because node <span>$L$</span> and nodes <span>$A_k$</span>, which form the information set of <span>$F$</span>, all have 2 states and node <span>$F$</span> itself also has 2 states. The orange colored dimensions correspond to the states of the action nodes <span>$A_k$</span>.</p><p>To set the probabilities we have to iterate over the information states. Here it helps to know that in Decision Programming the states of each node are mapped to numbers in the back-end. For instance, the load states <span>$high$</span> and <span>$low$</span> are referred to as 1 and 2. The same applies for the action states <span>$yes$</span> and <span>$no$</span>, they are states 1 and 2. The <code>paths</code> function allows us to iterate over the subpaths of specific nodes. In these paths, the states are referred to by their indices. Using this information, we can easily iterate over the information states using the <code>paths</code> function and enter the probability values into the probability matrix.</p><pre><code class="language-julia hljs">x_F, y_F = rand(2)
for s in paths([State(2) for i in 1:N])
    denominator = exp(b * sum(fortification(k, a) for (k, a) in enumerate(s)))
    X_F[1, s..., 1] = max(x_F, 1-x_F) / denominator
    X_F[1, s..., 2] = 1.0 - X_F[1, s..., 1]
    X_F[2, s..., 1] = min(y_F, 1-y_F) / denominator
    X_F[2, s..., 2] = 1.0 - X_F[2, s..., 1]
end</code></pre><p>After declaring the probability matrix, we add it to the influence diagram.</p><pre><code class="language-julia hljs">add_probabilities!(diagram, &quot;F&quot;, X_F)</code></pre><h3 id="Utility"><a class="docs-heading-anchor" href="#Utility">Utility</a><a id="Utility-1"></a><a class="docs-heading-anchor-permalink" href="#Utility" title="Permalink"></a></h3><p>The utility from the different scenarios of the failure state at target <span>$T$</span> are</p><p class="math-container">\[g(F=failure) = 0\]</p><p class="math-container">\[g(F=success) = 100.\]</p><p>Utilities from the action states <span>$A_k$</span>  at target <span>$T$</span> are</p><p class="math-container">\[f(A_k=yes) = c_k\]</p><p class="math-container">\[f(A_k=no) = 0.\]</p><p>The total cost is thus</p><p class="math-container">\[Y(F, A_N, ..., A_1) = g(F) + (-f(A_N)) + ... + (-f(A_1)).\]</p><p>We first declare the utility matrix for node <span>$T$</span>.</p><pre><code class="language-julia hljs">Y_T = UtilityMatrix(diagram, &quot;T&quot;)</code></pre><p>This matrix has dimensions <span>$(2, \textcolor{orange}{2, 2, 2, 2})$</span>, where the dimensions correspond to the numbers of states the nodes in the information set have. Similarly as before, the first dimension corresponds to the states of node <span>$F$</span> and the other 4 dimensions (in orange) correspond to the states of the <span>$A_k$</span> nodes. The utilities are set and added similarly to how the probabilities were added above.</p><pre><code class="language-julia hljs">for s in paths([State(2) for i in 1:N])
    cost = sum(-fortification(k, a) for (k, a) in enumerate(s))
    Y_T[1, s...] = 0 + cost
    Y_T[2, s...] = 100 + cost
end
add_utilities!(diagram, &quot;T&quot;, Y_T)</code></pre><h3 id="Generate-Influence-Diagram"><a class="docs-heading-anchor" href="#Generate-Influence-Diagram">Generate Influence Diagram</a><a id="Generate-Influence-Diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Influence-Diagram" title="Permalink"></a></h3><p>The full influence diagram can now be generated. We use the default path probabilities and utilities, which are the default setting in this function. In the <a href="../contingent-portfolio-programming/">Contingent Portfolio Programming</a> example, we show how to use a user-defined custom path utility function.</p><p>In this particular problem, some of the path utilities are negative. In this case, we choose to use the <a href="../../decision-programming/decision-model/">positive path utility</a> transformation, which translates the path utilities to positive values. This allows us to exclude the probability cut in the next section.</p><pre><code class="language-julia hljs">generate_diagram!(diagram, positive_path_utility = true)</code></pre><h2 id="Decision-Model"><a class="docs-heading-anchor" href="#Decision-Model">Decision Model</a><a id="Decision-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Decision-Model" title="Permalink"></a></h2><p>We initialise the JuMP model and declare the decision and path compatibility variables. Since we applied an affine transformation to the utility function, the probability cut can be excluded from the model formulation.</p><pre><code class="language-julia hljs">model = Model()
z = DecisionVariables(model, diagram)
x_s = PathCompatibilityVariables(model, diagram, z, probability_cut = false)</code></pre><p>The expected utility is used as the objective and the problem is solved using Gurobi.</p><pre><code class="language-julia hljs">EV = expected_value(model, diagram, x_s)
@objective(model, Max, EV)


optimizer = optimizer_with_attributes(
    () -&gt; Gurobi.Optimizer(Gurobi.Env()),
    &quot;IntFeasTol&quot;      =&gt; 1e-9,
)
set_optimizer(model, optimizer)
optimize!(model)</code></pre><h2 id="Analyzing-Results"><a class="docs-heading-anchor" href="#Analyzing-Results">Analyzing Results</a><a id="Analyzing-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-Results" title="Permalink"></a></h2><p>We obtain the decision strategy, state probabilities and utility distribution from the solution.</p><pre><code class="language-julia hljs">Z = DecisionStrategy(z)
U_distribution = UtilityDistribution(diagram, Z)
S_probabilities = StateProbabilities(diagram, Z)</code></pre><p>The decision strategy shows us that the optimal strategy is to make all four fortifications regardless of the reports.</p><pre><code class="language-julia-repl hljs">julia&gt; print_decision_strategy(diagram, Z, S_probabilities)
┌────────────────┬────────────────┐
│ State(s) of R1 │ Decision in A1 │
├────────────────┼────────────────┤
│ high           │ yes            │
│ low            │ yes            │
└────────────────┴────────────────┘
┌────────────────┬────────────────┐
│ State(s) of R2 │ Decision in A2 │
├────────────────┼────────────────┤
│ high           │ yes            │
│ low            │ yes            │
└────────────────┴────────────────┘
┌────────────────┬────────────────┐
│ State(s) of R3 │ Decision in A3 │
├────────────────┼────────────────┤
│ high           │ yes            │
│ low            │ yes            │
└────────────────┴────────────────┘
┌────────────────┬────────────────┐
│ State(s) of R4 │ Decision in A4 │
├────────────────┼────────────────┤
│ high           │ yes            │
│ low            │ yes            │
└────────────────┴────────────────┘</code></pre><p>The state probabilities for strategy <span>$Z$</span> are also obtained. These tell the probability of each state in each node, given strategy <span>$Z$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; print_state_probabilities(diagram, S_probabilities, [&quot;L&quot;])
┌────────┬──────────┬──────────┬─────────────┐
│   Node │     high │      low │ Fixed state │
│ String │  Float64 │  Float64 │      String │
├────────┼──────────┼──────────┼─────────────┤
│      L │ 0.564449 │ 0.435551 │             │
└────────┴──────────┴──────────┴─────────────┘
julia&gt; print_state_probabilities(diagram, S_probabilities, [[&quot;R$i&quot; for i in 1:N]...])
┌────────┬──────────┬──────────┬─────────────┐
│   Node │     high │      low │ Fixed state │
│ String │  Float64 │  Float64 │      String │
├────────┼──────────┼──────────┼─────────────┤
│     R1 │ 0.515575 │ 0.484425 │             │
│     R2 │ 0.442444 │ 0.557556 │             │
│     R3 │ 0.543724 │ 0.456276 │             │
│     R4 │ 0.552515 │ 0.447485 │             │
└────────┴──────────┴──────────┴─────────────┘
julia&gt; print_state_probabilities(diagram, S_probabilities, [[&quot;A$i&quot; for i in 1:N]...])
┌────────┬──────────┬──────────┬─────────────┐
│   Node │      yes │       no │ Fixed state │
│ String │  Float64 │  Float64 │      String │
├────────┼──────────┼──────────┼─────────────┤
│     A1 │ 1.000000 │ 0.000000 │             │
│     A2 │ 1.000000 │ 0.000000 │             │
│     A3 │ 1.000000 │ 0.000000 │             │
│     A4 │ 1.000000 │ 0.000000 │             │
└────────┴──────────┴──────────┴─────────────┘
julia&gt; print_state_probabilities(diagram, S_probabilities, [&quot;F&quot;])
┌────────┬──────────┬──────────┬─────────────┐
│   Node │  failure │  success │ Fixed state │
│ String │  Float64 │  Float64 │      String │
├────────┼──────────┼──────────┼─────────────┤
│      F │ 0.633125 │ 0.366875 │             │
└────────┴──────────┴──────────┴─────────────┘</code></pre><p>We can also print the utility distribution for the optimal strategy and some basic statistics for the distribution.</p><pre><code class="language-julia-repl hljs">julia&gt; print_utility_distribution(U_distribution)
┌───────────┬─────────────┐
│   Utility │ Probability │
│   Float64 │     Float64 │
├───────────┼─────────────┤
│ -2.881344 │    0.633125 │
│ 97.118656 │    0.366875 │
└───────────┴─────────────┘</code></pre><pre><code class="language-julia-repl hljs">julia&gt; print_statistics(U_distribution)
┌──────────┬────────────┐
│     Name │ Statistics │
│   String │    Float64 │
├──────────┼────────────┤
│     Mean │  33.806192 │
│      Std │  48.195210 │
│ Skewness │   0.552439 │
│ Kurtosis │  -1.694811 │
└──────────┴────────────┘</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Salo, A., Andelmin, J., &amp; Oliveira, F. (2019). Decision Programming for Multi-Stage Optimization under Uncertainty, 1–35. Retrieved from <a href="http://arxiv.org/abs/1910.09196">http://arxiv.org/abs/1910.09196</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pig-breeding/">« Pig Breeding</a><a class="docs-footer-nextpage" href="../contingent-portfolio-programming/">Contingent Portfolio Programming »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 7 December 2022 11:38">Wednesday 7 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
